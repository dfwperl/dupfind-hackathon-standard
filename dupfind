#!/usr/bin/env perl

use 5.010;

BEGIN { $|++ }

use warnings;
use strict;

use File::Util;
use Digest::xxHash 'xxhash_hex';
use Getopt::Long;
use Term::Prompt 'prompt';
use Benchmark ':hireswallclock';

my $opts =
{
   dir      => undef,
   help     => undef,
   bytes    => 1024 ** 3, # 1 GB max read
   maxdepth => 10,
   prompt   => 0,
   remove   => 0,
   links    => 0,
   format   => 'human', # formatting options are either "human" or "robot"
   weed     => 0,
};

GetOptions
(
   'dir|d=s'      => \$opts->{dir},
   'bytes|b=s'    => \$opts->{bytes},
   'maxdepth|m=s' => \$opts->{maxdepth},
   'links|l=s'    => \$opts->{links},
   'prompt|p'     => \$opts->{prompt},
   'remove|r'     => \$opts->{remove},
   'delete'       => \$opts->{remove}, # <-- that's not a typo
   'help|h|?'     => \$opts->{help},
   'format|f=s'   => \$opts->{format},
   'weed|w'       => \$opts->{weed},
) or die usage();

die usage() unless defined $opts->{dir};

$opts->{remove}++ if $opts->{prompt};

my $ftl = File::Util->new
(
   {
      use_flock   => 0,
      diag        => 1,
      read_limit  => $opts->{bytes},
      abort_depth => $opts->{maxdepth},
      onfail      => 'undefined',
   }
);


my
(
   $cmp_count,  $size_dup_count,
   $dup_count,  $weeding_time,
   $scan_time,  $hashing_time,
   $del_time,   $run_time
) = run();

$scan_time    = timestr $scan_time;
$weeding_time = timestr $weeding_time;
$hashing_time = timestr $hashing_time;
$run_time     = timestr $run_time;
$del_time     = $opts->{remove} ? timestr $del_time : 0;

say <<__SUMMARY__;
------------------------------
** THREADS:             None
** TOTAL FILES SCANNED: $cmp_count
** TOTAL SAME SIZE:     $size_dup_count
** TOTAL ACTUAL DUPES:  $dup_count
** TREE SCAN TIME:      $scan_time
** WEED-OUT TIME:       $weeding_time
** CRYPTO-HASHING TIME: $hashing_time
** DELETION TIME:       $del_time
** TOTAL RUN TIME:      $run_time
__SUMMARY__

exit;



sub run
{
   my $start_of_run   = Benchmark->new();
   my $start_of_scan  = Benchmark->new();
   my $size_dup_count = 0;

   say '** SCANNING ALL FILES FOR SIZE DUPLICATES';

   my ( $sizes, $cmp_count ) = get_dup_sizes();

   my $end_of_scan = Benchmark->new();

   say '** NO DUPLICATES FOUND' and exit unless keys %$sizes;


   say '** WEEDING-OUT FILES THAT ARE OBVIOUSLY DIFFERENT' if $opts->{weed};

   my $start_of_weeding = Benchmark->new();

   $sizes = remove_obviously_different( $sizes ) if $opts->{weed};

   $size_dup_count = keys %$sizes;

   my $end_of_weeding = Benchmark->new();

   say '** NO DUPLICATES FOUND' and exit unless $size_dup_count;


   say '** CHECKSUMMING SIZE DUPLICATES';

   my $start_of_hashing = Benchmark->new();

   my $hashes = get_dup_hashes( $sizes );

   my $end_of_hashing = Benchmark->new();

   undef $sizes; # free up some RAM

   say '** NO DUPLICATES FOUND' and exit unless keys %$hashes;

   say '** DISPLAYING OUTPUT';

   say '-' x 30;

   my $dup_count  = show_dups( $hashes );

   my $start_of_del = Benchmark->new();

   delete_dups( $hashes ) if $opts->{remove};

   my $end_of_del = Benchmark->new();

   my $end_of_run   = Benchmark->new();

   return $cmp_count,
          $size_dup_count,
          $dup_count,
          timediff( $end_of_weeding, $start_of_weeding ),
          timediff( $end_of_scan,    $start_of_scan    ),
          timediff( $end_of_hashing, $start_of_hashing ),
          timediff( $end_of_del,     $start_of_del     ),
          timediff( $end_of_run,     $start_of_run     );
}

sub get_dup_sizes
{
   my ( $sizes, $cmp_count ) = ( {}, 0 );

   $ftl->list_dir
   (
      $opts->{dir} =>
      {
         recurse => 1,
         callback => sub
            {
               my ( $selfdir, $subdirs, $files ) = @_;

               push @{ $sizes->{ -s $_ } }, $_
                  for grep { !-l $_ && defined -s $_ } @$files;
            }
      }
   );

   $cmp_count = keys %$sizes;

   delete $sizes->{ $_ }
      for grep { @{ $sizes->{ $_ } } == 1 }
      keys %$sizes;

   return $sizes, $cmp_count;
}

sub remove_obviously_different
{
   # weed out files that are obviously different, based on the last
   # few bytes in the file.  This saves us from unnecessary hashing

   my $size_matches = shift;
   my $zero_sized   = delete $size_matches->{0};

   for my $same_size ( keys %$size_matches )
   {
      my @group = sort { $a cmp $b } @{ $size_matches->{ $same_size } };

      my $same_last_bytes = {};

      for my $file ( @group )
      {
         my $last_bytes = get_file_lastbytes( $file => $same_size );

         push @{ $same_last_bytes->{ $last_bytes } }, $file;
      }

      # delete obvious non-dupe files from the group of same-size files
      # by virtue of the fact that they will be a single length arrayref

      delete $same_last_bytes->{ $_ }
         for grep { @{ $same_last_bytes->{ $_ } } == 1 }
         keys %$same_last_bytes;

      # recompose the arrayref of filenames for the same-size file grouping
      # but leave out the files we just weeded out from the group

      $size_matches->{ $same_size } = []; # start fresh

      push @{ $size_matches->{ $same_size } },
         map { @{ $same_last_bytes->{ $_ } } }
         keys %$same_last_bytes;
   }

   $size_matches->{0} = $zero_sized if ref $zero_sized;

   return $size_matches;
}

sub get_file_lastbytes
{
   my ( $file, $len ) = @_;

   my $buff;

   sysopen my $fh, $file, 0;

   return unless defined $fh;

   sysseek $fh, $len - 1024, 0;

   sysread $fh, $buff, 1024;

   close $fh or return;

   return $buff;
}

sub get_dup_hashes
{
   my $sizes  = shift;
   my $hashes = {};

   local $/;

   for my $size ( keys %$sizes )
   {
      my $group = $sizes->{ $size };
      my %dev_inodes;

      # this will automatically throw out hardlinks, with the only surviving
      # file being the first asciibetically-sorted entry
      $dev_inodes{ join '', ( stat $_ )[0,1] } = $_ for reverse sort @$group;

      next if scalar keys %dev_inodes == 1;

      for my $file ( values %dev_inodes )
      {
         open my $fh, '<', $file or next;

         my $data = <$fh>;

         close $fh;

         my $hash = xxhash_hex $data, 0;

         push @{ $hashes->{ $hash } }, $file
      }
   }

   delete $hashes->{ $_ }
      for grep { @{ $hashes->{ $_ } } == 1 }
      keys %$hashes;

   my $priv_hashes = {};

   # sort dup groupings
   for my $hash ( keys %$hashes )
   {
      my @group = @{ $hashes->{ $hash } };

      $priv_hashes->{ $hash } = [ sort { $a cmp $b } @group ];
   }

   undef $hashes;

   return $priv_hashes;
}

sub show_dups
{
   my $hashes = shift;
   my $dupes  = 0;

   my $for_humans = sub # human-readable output
   {
      my ( $hash, $files ) = @_;

      say sprintf 'DUPLICATES (hash: %s | size: %db)', $hash, -s $$files[0];

      say "   $_" for @$files;

      say '';
   };

   my $for_robots = sub # machine parseable output
   {
      my ( $hash, $files ) = @_;

      say join "\t", @$files
   };

   my $formatter = $opts->{format} eq 'human' ? $for_humans : $for_robots;

   for my $hash
   (
      sort { $hashes->{ $a }->[0] cmp $hashes->{ $b }->[0] } keys %$hashes
   )
   {
      my $files = $hashes->{ $hash };

      $formatter->( $hash => $files );

      $dupes += @$files - 1;
   }

   return $dupes
}

sub delete_dups
{
   my $hashes  = shift;

   my $removed = 0;

   for my $hash ( keys %$hashes )
   {
      my $group = $hashes->{ $hash };

      say sprintf 'KEPT    (%s) %s', $hash, $group->[0];

      shift @$group;

      for my $dup ( @$group )
      {
         if ( $opts->{prompt} )
         {
            unless ( prompt 'y', "REMOVE DUPLICATE? $dup", '', 'n' )
            {
               say sprintf 'KEPT    (%s) %s', $hash, $dup;

               next;
            }
         }

         unlink $dup or warn "COULD NOT REMOVE $dup!  $!" and next;

         $removed++;

         say sprintf 'REMOVED (%s) %s', $hash, $dup;
      }

      say '--';
   }

   say "** TOTAL DUPLICATE FILES REMOVED: $removed"
}

# This is just the help message:

sub usage { <<'__USAGE__' }
USAGE:
   dupfind [ --options ] --dir ./path/to/search/

DESCRIPTION:
   finds duplicate files in a directory tree.  Options are explained
   in detail below.  Options marked with an asterisk (*) are not yet
   implemented and are planned for a future release

ARGUMENTS AND FLAGS:
   -b, --bytes    Maximum size in bytes that you are willing to compare.
                  The current default maximum is 1 gigabyte.

                  Sizing guide:
                     1 kilobyte = 1024
                     1 megabyte = 1048576        or 1024 ** 2
                     1 gigabyte = 1073741824     or 1024 ** 3
                     1 terabyte = 1099511627776  or 1024 ** 4

   -d, --dir      Name of the directory you want to search for duplicates

*  -l, --links    Follow symlinks (by default it does not).  Because this
                  has some safety implications and is a complex matter,
                  it is not yet supported.  Sorry, check back later.

   -m, --maxdepth The maximum directory depth to which the comparison
                  scan will recurse.  Note that this does not mean the
                  total number of directories to scan

   -p, --prompt   Interactively prompt user to delete detected duplicates

   -r, --remove   Delete (WITHOUT PROMPTING) all but the first copy if
                  duplicate files are found.  This will leave you with no
                  duplicate files when execution is finished

   -f, --format   Specify either "human" or "robot".  Human-readable output
                  is generated for easy viewing by default.  If you want output
                  that is machine-parseable, specify "robot"

   -w, --weed     Default: disabled.  Try to avoid unnecessary file hashing
                  by weeding out potential duplicates with a simple, quick
                  comparison of the last 1024 bytes of data in same-size files.
                  In some cases this produces performance gains.  In situations
                  where you have a very large number of small files, it could
                  actually have the opposite effect.

__USAGE__
